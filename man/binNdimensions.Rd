% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ndimensional_binning.R
\name{binNdimensions}
\alias{binNdimensions}
\alias{aggregateByNdimBins}
\alias{densityInNdimBins}
\title{Generating and Aggregating Data Within N-dimensional Bins}
\usage{
binNdimensions(
  dims.df,
  nbins = 10L,
  use_bin_numbers = TRUE,
  ncores = getOption("mc.cores", 2L)
)

aggregateByNdimBins(
  x,
  dims.df,
  nbins = 10L,
  FUN = mean,
  ...,
  ignore.na = TRUE,
  drop = FALSE,
  empty = NA,
  use_bin_numbers = TRUE,
  ncores = getOption("mc.cores", 2L)
)

densityInNdimBins(
  dims.df,
  nbins = 10L,
  use_bin_numbers = TRUE,
  ncores = getOption("mc.cores", 2L)
)
}
\arguments{
\item{dims.df}{A dataframe containing one or more columns of numerical data
for which bins will be generated.}

\item{nbins}{Either a number giving the number of bins to use for all
dimensions (default = 10), or a vector containing the number of bins to use
for each dimension of input data given.}

\item{use_bin_numbers}{A logical indicating if ordinal bin numbers should be
returned (\code{TRUE}), or if in place of the bin number, the center value
of that bin should be returned. For instance, if the first bin encompasses
data from 1 to 3, with \code{use_bin_numbers = TRUE}, a 1 is returned, but
when \code{FALSE}, 2 is returned.}

\item{ncores}{Number of cores to use for computations.}

\item{x}{The name of the dimension in \code{dims.df} to aggregate, or a
separate numerical vector or dataframe of data to be aggregated. If
\code{x} is a numerical vector, each value in \code{x} corresponds to a row
of \code{dims.df}, and so \code{length(x)} must be equal to
\code{nrow(dims.df)}. Likewise, if \code{x} is a dataframe, \code{nrow(x)}
must equal \code{nrow(dims.df)}. Supplying a dataframe for \code{x} has the
advantage of simultaneously aggregating different sets of data, and
returning a single dataframe.}

\item{FUN}{A function to use for aggregating data within each bin.}

\item{...}{Additional arguments passed to \code{FUN}.}

\item{ignore.na}{Logical indicating if \code{NA} values of \code{x} should be
ignored. Default is \code{TRUE}.}

\item{drop}{A logical indicating if empty bin combinations should be removed
from the output. By default (\code{FALSE}), all possible combinations of
bins are returned, and empty bins contain a value given by \code{empty}.}

\item{empty}{When \code{drop = FALSE}, the value returned for empty bins. By
default, empty bins return \code{NA}. However, in many circumstances (e.g.
if \code{FUN = sum}), the empty value should be \code{0}.}
}
\value{
A dataframe.
}
\description{
Divide data along different dimensions into equally spaced bins, and
summarize the datapoints that fall into any of these n-dimensional bins.
}
\details{
These functions take in data along 1 or more dimensions, and for
  each dimension the data is divided into evenly-sized bins from the minimum
  value to the maximum value. For instance, if each row of \code{dims.df}
  were a gene, the columns (the different dimensions) would be various
  quantitative measures of that gene, e.g. expression level, number of exons,
  length, etc. If plotted in cartesian coordinates, each gene would be a
  single datapoint, and each measurement would be a separate dimension.

  \code{binNdimensions} returns the bin numbers themselves. The output
  dataframe has the same dimensions as the input \code{dims.df}, but each
  input data has been replaced by its bin number (an integer). If
  code{use_bin_numbers = FALSE}, the center points of the bins are returned
  instead of the bin numbers.

  \code{aggregateByNdimBins} summarizes some input data \code{x} in each
  combination of bins, i.e. in each n-dimensional bin. Each row of the output
  dataframe is a unique combination of the input bins (i.e. each
  n-dimensional bin), and the output columns are identical to those in
  \code{dims.df}, with the addition of one or more columns containing the
  aggregated data in each n-dimensional bin. If the input \code{x} was a
  vector, the column is named "value"; if the input \code{x} was a dataframe,
  the column names from \code{x} are maintained.

  \code{densityInNdimBins} returns a dataframe just like
  \code{aggregateByNdimBins}, except the "value" column contains the number
  of observations that fall into each n-dimensional bin.
}
\examples{
data("PROseq") # import included PROseq data
data("txs_dm6_chr4") # import included transcripts

#--------------------------------------------------#
# find counts in promoter, early genebody, and near CPS
#--------------------------------------------------#

pr <- promoters(txs_dm6_chr4, 0, 100)
early_gb <- genebodies(txs_dm6_chr4, 500, 1000, fix.end = "start")
cps <- genebodies(txs_dm6_chr4, -500, 500, fix.start = "end")

df <- data.frame(counts_pr = getCountsByRegions(PROseq, pr),
                 counts_gb = getCountsByRegions(PROseq, early_gb),
                 counts_cps = getCountsByRegions(PROseq, cps))

#--------------------------------------------------#
# divide genes into 20 bins for each measurement
#--------------------------------------------------#

bin3d <- binNdimensions(df, nbins = 20, ncores = 1)

length(txs_dm6_chr4)
nrow(bin3d)
bin3d[1:6, ]

#--------------------------------------------------#
# get number of genes in each bin
#--------------------------------------------------#

bin_counts <- densityInNdimBins(df, nbins = 20, ncores = 1)

bin_counts[1:6, ]

#--------------------------------------------------#
# get mean cps reads in bins of promoter and genebody reads
#--------------------------------------------------#

bin2d_cps <- aggregateByNdimBins("counts_cps", df, nbins = 20,
                                 ncores = 1)

bin2d_cps[1:6, ]

subset(bin2d_cps, is.finite(counts_cps))[1:6, ]

#--------------------------------------------------#
# get median cps reads for those bins
#--------------------------------------------------#

bin2d_cps_med <- aggregateByNdimBins("counts_cps", df, nbins = 20,
                                     FUN = median, ncores = 1)

bin2d_cps_med[1:6, ]

subset(bin2d_cps_med, is.finite(counts_cps))[1:6, ]
}
\author{
Mike DeBerardine
}
